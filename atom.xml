<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Ethan</title>
  
  <subtitle>Ethan&#39;s blog</subtitle>
  <link href="http://yoursite.com/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-08-25T05:35:55.992Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Ethan</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>KNN近邻算法学习笔记</title>
    <link href="http://yoursite.com/2020/08/25/KNN%E8%BF%91%E9%82%BB%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2020/08/25/KNN%E8%BF%91%E9%82%BB%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</id>
    <published>2020-08-25T05:35:55.992Z</published>
    <updated>2020-08-25T05:35:55.992Z</updated>
    
    <content type="html"><![CDATA[<h1 id="K近邻算法"><a href="#K近邻算法" class="headerlink" title="K近邻算法"></a>K近邻算法</h1><p>&amp;emspk近邻法是一种基本分类与回归方法。K近邻法输入为实例的特征向量，对应于特征空间的点，输出为实例的类别，可以取多类。</p><p>&amp;emsp分类时，对于新的实例，根据其k个最近邻的训练实例的类别，通过多数表决等方式进行预测。因此，k近邻法不具有显式的学习过程。</p><p><strong>关键词</strong>：多数表决</p><p>k近邻算法利用训练数据集对特征向量空间进行划分，并作为其分类的模型。</p><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><p>输入训练数据集，输出实例所属的类别。</p><ol><li>根据给定的距离度量，在训练集中找出与x最邻近的k个点，涵盖这k个点的x的邻域。</li><li>根据多数表决决定x类别。</li></ol><h2 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h2><p>距离度量包括欧氏距离，曼哈顿距离。</p><p>k值的选择：过大造成欠拟合，过小造成过拟合。</p><p>分类决策规则：多数表决规则</p><h2 id="K近邻算法的实现-kd树"><a href="#K近邻算法的实现-kd树" class="headerlink" title="K近邻算法的实现 kd树"></a>K近邻算法的实现 kd树</h2><p>构造kd树，二叉排序树。</p><p>对kd树进行搜索。</p><h2 id="代码案例解析"><a href="#代码案例解析" class="headerlink" title="代码案例解析"></a>代码案例解析</h2><p>知识总结：近朱者赤近墨者黑</p><ol><li>假设有一个带有标签的样本数据集（训练样本集），其中包含每条数据与所属分类的对应关系。</li><li>输入没有标签的新数据后，将新数据每个特征与样本集中数据对应的特征进行比较。<ol><li>计算新数据与样本数据集中每条数据的距离</li><li>对求得的所有距离进行排序，从小到大，越小表示越相似。</li><li>取前k个样本数据对应的分类标签。</li></ol></li><li>求k个数据中出现次数最多的分类标签作为新数据的分类。</li></ol><p>案例：优化约会网站的配对效果</p><p>&amp;emsp海伦使用约会网站寻找约会对象，经过一段时间后，她发现她曾交往过三种类型的人：</p><ul><li>不喜欢的人</li><li>魅力一般的人</li><li>极具魅力的人</li></ul><p>她希望：</p><ol><li>工作日与魅力一般的人约会</li><li>周末与极具魅力的人约会</li><li>不喜欢的人则直接排除掉</li></ol><p>1、将文本记录转换为numpy的解析程序</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">file2matrix</span><span class="params">(filename)</span>:</span></span><br><span class="line">  <span class="string">"""</span></span><br><span class="line"><span class="string">  Desc:</span></span><br><span class="line"><span class="string">  导入训练数据</span></span><br><span class="line"><span class="string">  parameters:</span></span><br><span class="line"><span class="string">  filename:数据文件路径</span></span><br><span class="line"><span class="string">  return:</span></span><br><span class="line"><span class="string">  数据矩阵 returnMat 对应的类别 classLabelVector</span></span><br><span class="line"><span class="string">  """</span></span><br><span class="line">  fr=open(filename) <span class="comment">#读入文件</span></span><br><span class="line">  numberOfLines=len(fr.readlines()) <span class="comment">#得到行的个数</span></span><br><span class="line">  returnMat=zeros((numberOfLines,<span class="number">3</span>)) <span class="comment">#创建范围矩阵，各个位置都是0</span></span><br><span class="line">  classLabelVector=[] <span class="comment">#创建标签列表</span></span><br><span class="line">  fr=open(filename)</span><br><span class="line">  index=<span class="number">0</span></span><br><span class="line">  <span class="keyword">for</span> line <span class="keyword">in</span> fr.readlines(): <span class="comment">#读取一行</span></span><br><span class="line">    line=line.strip() <span class="comment">#去掉首尾</span></span><br><span class="line">    listFromLine=Line.split(<span class="string">'\t'</span>) <span class="comment">#以\t切割字符串，返回列表</span></span><br><span class="line">    returnMat[index,:]=listFromLine[<span class="number">0</span>:<span class="number">3</span>] <span class="comment">#赋给矩阵第index行的三列</span></span><br><span class="line">    classLabel.append(int(listFromLine[<span class="number">-1</span>])) <span class="comment">#将此时的类别添加到标签列表末端</span></span><br><span class="line">    index+=<span class="number">1</span> <span class="comment">#进行下一次循环</span></span><br><span class="line">  <span class="keyword">return</span> returnMat,classLabelVector</span><br></pre></td></tr></table></figure><p>程序解读：</p><p>目标：将文本转化为对应矩阵形式</p><p>2、归一化数据</p><p>其实，归一化是一个让 权重 变为统一的过程。如国际上以美元为结算通用货币，想买入10吨铁矿，用的人民币和美币不同，那么就需要一个统一的标准衡量，规定用美元统一结算，货币本身也是归一化过程。</p><p>归一化方法：</p><ul><li>线性函数转换</li><li>对数函数转换</li><li>反余切函数转换</li></ul><p>代码实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">auwoNorm</span><span class="params">(dataSet)</span>:</span></span><br><span class="line">  <span class="string">"""</span></span><br><span class="line"><span class="string">  Desc：</span></span><br><span class="line"><span class="string">  归一化特征值，消除特征之间量级不同导致的影响。</span></span><br><span class="line"><span class="string">  parameter：</span></span><br><span class="line"><span class="string">  dataSet：数据集 （矩阵）</span></span><br><span class="line"><span class="string">  return：</span></span><br><span class="line"><span class="string">  归一化后的数据集</span></span><br><span class="line"><span class="string">  归一化公式：Y=（X-Xmin)/(Xmax-Xmin)</span></span><br><span class="line"><span class="string">  """</span></span><br><span class="line">  minVals=dataSet.min(<span class="number">0</span>)<span class="comment">#numpy api 得到数据集中最小最大特征值</span></span><br><span class="line">  maxVals=dataSet.max(<span class="number">0</span>)</span><br><span class="line">  ranges=maxVals-minVals <span class="comment">#极差</span></span><br><span class="line">  normDataSet=zeros（shape（dataSet））<span class="comment">#生成零矩阵</span></span><br><span class="line">  m=dataSet.shape[<span class="number">0</span>] <span class="comment">#返回行数</span></span><br><span class="line">  normDataSet=dataSet-tile(minVals,(m,<span class="number">1</span>))  <span class="comment">#tile函数</span></span><br><span class="line">  normDataSet=normDataSet/tile(ranges,(m,<span class="number">1</span>))</span><br><span class="line">  <span class="keyword">return</span> normDataSet,ranges,minvals</span><br></pre></td></tr></table></figure><h3 id="KNN算法"><a href="#KNN算法" class="headerlink" title="KNN算法"></a>KNN算法</h3><p>对于每一个在数据集中的数据点：</p><ol><li>计算目标的数据点与该数据点的距离</li><li>将距离从小到大排序</li><li>选取前k个最短距离</li><li>选取这K个中最多的分类类别</li><li>返回该类别来作为目标数据点的预测值</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">classify0</span><span class="params">(inX, dataSet, labels, k)</span>:</span></span><br><span class="line">    dataSetSize = dataSet.shape[<span class="number">0</span>]</span><br><span class="line">    <span class="comment">#距离度量 度量公式为欧氏距离</span></span><br><span class="line">    diffMat = tile(inX, (dataSetSize,<span class="number">1</span>)) – dataSet</span><br><span class="line">    sqDiffMat = diffMat**<span class="number">2</span></span><br><span class="line">    sqDistances = sqDiffMat.sum(axis=<span class="number">1</span>)</span><br><span class="line">    distances = sqDistances**<span class="number">0.5</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">#将距离排序: 从小到大</span></span><br><span class="line">    sortedDistIndicies = distances.argsort()</span><br><span class="line">    <span class="comment">#选取前K个最短距离， 选取这K个中最多的分类类别</span></span><br><span class="line">    classCount=&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(k): </span><br><span class="line">        voteIlabel = labels[sortedDistIndicies[i]]</span><br><span class="line">        classCount[voteIlabel] = classCount.get(voteIlabel,<span class="number">0</span>) + <span class="number">1</span> </span><br><span class="line">    sortedClassCount = sorted(classCount.iteritems(), key=operator.itemgetter(<span class="number">1</span>), reverse=<span class="literal">True</span>)</span><br><span class="line">    <span class="keyword">return</span> sortedClassCount[<span class="number">0</span>][<span class="number">0</span>]</span><br></pre></td></tr></table></figure><p><strong>KNN分类器针对约会网站的测试代码</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">datingClassTest</span><span class="params">()</span>:</span></span><br><span class="line">  <span class="string">"""</span></span><br><span class="line"><span class="string">  Desc:</span></span><br><span class="line"><span class="string">  对约会网站的测试方法</span></span><br><span class="line"><span class="string">  parameters:</span></span><br><span class="line"><span class="string">  none</span></span><br><span class="line"><span class="string">  return:</span></span><br><span class="line"><span class="string">  错误数</span></span><br><span class="line"><span class="string">  """</span></span><br><span class="line">  hoRatio=<span class="number">0.1</span> <span class="comment">#测试比例</span></span><br><span class="line">  datingDataMat,datingLabels=file2matrix(<span class="string">"....txt"</span>)</span><br><span class="line">  norMat,ranges,minVals=autoNorm(datingDataMat)<span class="comment">#归一化数据</span></span><br><span class="line">  m=normMat.shape[<span class="number">0</span>]</span><br><span class="line">  numTestVecs=int(m*hoRatio)</span><br><span class="line">  errorCount=<span class="number">0.0</span></span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> range(numTestVecs):</span><br><span class="line">    classifierResult=classify0(normMat[i,:],normMat[numTestVecs:m,:],datingLabels[numTestVecs:m],<span class="number">3</span>)</span><br><span class="line">      <span class="keyword">if</span>(classifierResult!datingLabels[i]):errorCount+=<span class="number">1.0</span></span><br><span class="line">  <span class="keyword">print</span> errorCount</span><br></pre></td></tr></table></figure><p>约会预测函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">handwritingClassTest</span><span class="params">()</span>:</span></span><br><span class="line">  resultList=[<span class="string">'not at all'</span>,<span class="string">'in small doses'</span>,<span class="string">'in large doses'</span>]</span><br><span class="line">  percentTats=float(raw_input(<span class="string">"percentage of time spent playing video games?"</span>))</span><br><span class="line">  ffMiles=float(raw_input(<span class="string">"frequent filer miles earned per year?"</span>))</span><br><span class="line">  iceCream=float(raw_input(<span class="string">"liters of ice cream consumed per year"</span>))</span><br><span class="line">  datingDataMat,datingLabels=file2matrix(<span class="string">'datingTestSet2.txt'</span>)</span><br><span class="line">  normMat,ranges,minVals=autoNorm(datingDataMat)</span><br><span class="line">  inArr=array[ffMiles,percentTats,iceCream]</span><br><span class="line">  classifierResult=classify0((inArr-minVals)/ranges,normMat,datingLabels,<span class="number">3</span>)</span><br><span class="line">  <span class="keyword">print</span> resultList[classifierResult<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><h2 id="项目二-手写数字识别系统"><a href="#项目二-手写数字识别系统" class="headerlink" title="项目二 手写数字识别系统"></a>项目二 手写数字识别系统</h2><p>构造一个能识别数字0到9的基于KNN分类器的 手写数字识别系统</p><p>开发流程</p><ol><li>收集数据：提供文本文件</li><li>准备数据：编写函数，将图像格式转换为分类器使用的向量格式</li><li>分析数据</li><li>训练算法</li><li>测试算法</li><li>使用算法</li></ol><p>将图像文本数据转化为向量</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">img2vector</span><span class="params">(filename)</span>:</span></span><br><span class="line">  returnVect=zeros((<span class="number">1</span>,<span class="number">1024</span>))</span><br><span class="line">  fr=open(filename)</span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">32</span>):</span><br><span class="line">    lineStr=fr.readline()</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">32</span>):</span><br><span class="line">      returnVect[<span class="number">0</span>,<span class="number">32</span>*i+j]=int(lineStr[j])</span><br><span class="line">  <span class="keyword">return</span> returnVect</span><br></pre></td></tr></table></figure><p>测试程序</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">handwritingClassTest</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># 1. 导入数据</span></span><br><span class="line">    hwLabels = []</span><br><span class="line">    trainingFileList = listdir(<span class="string">'data/2.KNN/trainingDigits'</span>)  <span class="comment"># load the training set</span></span><br><span class="line">    m = len(trainingFileList)</span><br><span class="line">    trainingMat = zeros((m, <span class="number">1024</span>))</span><br><span class="line">    <span class="comment"># hwLabels存储0～9对应的index位置， trainingMat存放的每个位置对应的图片向量</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line">        fileNameStr = trainingFileList[i]</span><br><span class="line">        fileStr = fileNameStr.split(<span class="string">'.'</span>)[<span class="number">0</span>]  <span class="comment"># take off .txt</span></span><br><span class="line">        classNumStr = int(fileStr.split(<span class="string">'_'</span>)[<span class="number">0</span>])</span><br><span class="line">        hwLabels.append(classNumStr)</span><br><span class="line">        <span class="comment"># 将 32*32的矩阵-&gt;1*1024的矩阵</span></span><br><span class="line">        trainingMat[i, :] = img2vector(<span class="string">'data/2.KNN/trainingDigits/%s'</span> % fileNameStr)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 2. 导入测试数据</span></span><br><span class="line">    testFileList = listdir(<span class="string">'data/2.KNN/testDigits'</span>)  <span class="comment"># iterate through the test set</span></span><br><span class="line">    errorCount = <span class="number">0.0</span></span><br><span class="line">    mTest = len(testFileList)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(mTest):</span><br><span class="line">        fileNameStr = testFileList[i]</span><br><span class="line">        fileStr = fileNameStr.split(<span class="string">'.'</span>)[<span class="number">0</span>]  <span class="comment"># take off .txt</span></span><br><span class="line">        classNumStr = int(fileStr.split(<span class="string">'_'</span>)[<span class="number">0</span>])</span><br><span class="line">        vectorUnderTest = img2vector(<span class="string">'data/2.KNN/testDigits/%s'</span> % fileNameStr)</span><br><span class="line">        classifierResult = classify0(vectorUnderTest, trainingMat, hwLabels, <span class="number">3</span>)</span><br><span class="line">        print(<span class="string">"the classifier came back with: %d, the real answer is: %d"</span> % (classifierResult, classNumStr))</span><br><span class="line">        <span class="keyword">if</span> (classifierResult != classNumStr): errorCount += <span class="number">1.0</span></span><br><span class="line">    print(<span class="string">"\nthe total number of errors is: %d"</span> % errorCount)</span><br><span class="line">    print(<span class="string">"\nthe total error rate is: %f"</span> % (errorCount / float(mTest)))</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;K近邻算法&quot;&gt;&lt;a href=&quot;#K近邻算法&quot; class=&quot;headerlink&quot; title=&quot;K近邻算法&quot;&gt;&lt;/a&gt;K近邻算法&lt;/h1&gt;&lt;p&gt;&amp;amp;emspk近邻法是一种基本分类与回归方法。K近邻法输入为实例的特征向量，对应于特征空间的点，输出为实例的类</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>MIT Linear Algebra 一</title>
    <link href="http://yoursite.com/2020/08/18/MIT%20Linear%20Algebra%20%E4%B8%80/"/>
    <id>http://yoursite.com/2020/08/18/MIT%20Linear%20Algebra%20%E4%B8%80/</id>
    <published>2020-08-17T16:00:00.000Z</published>
    <updated>2020-08-18T18:44:38.370Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第一讲-解决线形方程"><a href="#第一讲-解决线形方程" class="headerlink" title="第一讲 解决线形方程"></a>第一讲 解决线形方程</h1><h2 id="向量和线形方程"><a href="#向量和线形方程" class="headerlink" title="向量和线形方程"></a>向量和线形方程</h2><h3 id="二维情况"><a href="#二维情况" class="headerlink" title="二维情况"></a>二维情况</h3><p>我们首先来看这样一个式子</p><script type="math/tex; mode=display">x-2y=1 \\3x+2y=11</script><p>把这个方程的左边写成系数矩阵形式也就是</p><script type="math/tex; mode=display">\begin{bmatrix} 1 & 3 \\ 3 & 2 \\ \end{bmatrix}\begin{bmatrix} x\\y   \end{bmatrix}=\begin{bmatrix} 1 \\ 11\\ \end{bmatrix}\\AX=b</script><h4 id="二维图像"><a href="#二维图像" class="headerlink" title="二维图像"></a>二维图像</h4><p>做出图像是什么形式的呢？</p><p><img src= "/img/loading.gif" data-lazy-src="/2020/08/18/MIT Linear Algebra 第一讲/截屏2020-08-18 下午10.43.48.png" alt="截屏2020-08-18 下午10.43.48" style="zoom:50%;"></p><p>两条线的交点就是直线的解。</p><h4 id="二维矩阵形式"><a href="#二维矩阵形式" class="headerlink" title="二维矩阵形式"></a>二维矩阵形式</h4><p>如果把系数矩阵A拆分成列的形式，那么方程就可以如下表示：</p><p><img src= "/img/loading.gif" data-lazy-src="/2020/08/18/MIT Linear Algebra 一/截屏2020-08-18 下午10.56.36.png" alt="截屏2020-08-18 下午10.43.48" style="zoom:50%;"></p><p>那么我们思考一下，这个方程的目的是什么呢？</p><p>目的是如何将 2 ，-1 这个向量和另一个 -1 ，2 向量进行线性组合。求x，y就是求这个线性组合，对于矩阵来说也就是列向量的线性组合。需要求出两个数值得到【0，3】这个向量。</p><h4 id="二维向量表示"><a href="#二维向量表示" class="headerlink" title="二维向量表示"></a>二维向量表示</h4><p>在图像中我们可以将这两个列向量表示出来，并用列向量来表示出b向量。</p><p><img src= "/img/loading.gif" data-lazy-src="/2020/08/18/MIT Linear Algebra 一/截屏2020-08-18 下午10.56.12.png" alt="截屏2020-08-18 下午10.43.48" style="zoom:50%;"></p><p>那么依然是这个图像，思考一个问题：这两个列向量所有的线性组合是什么呢？也就是说x y 选取不同值得时候，我们会得到什么样的结果。</p><p>我们会得到任意的向量，也就是说，通过这两个向量改变系数，我们所得到的向量会布满整个坐标系。</p><p>通过对列向量特定的线性组合，可以求出向量b，而所有的线性组合可以求出所有可能的右侧向量。</p><h3 id="三维情况"><a href="#三维情况" class="headerlink" title="三维情况"></a>三维情况</h3><p>三个方程情况下呢？</p><p><img src= "/img/loading.gif" data-lazy-src="/2020/08/18/MIT Linear Algebra 一/截屏2020-08-18 下午11.00.40.png" alt="截屏2020-08-18 下午10.43.48" style="zoom:50%;"></p><h4 id="三维图像"><a href="#三维图像" class="headerlink" title="三维图像"></a>三维图像</h4><p>画出图像，前两个方程得到一个平面，第三个方程与其交于一点，就是方程的解。</p><p><img src= "/img/loading.gif" data-lazy-src="/2020/08/18/MIT Linear Algebra 一/截屏2020-08-18 下午10.43.48.png" alt="截屏2020-08-18 下午10.43.48" style="zoom:50%;"></p><h4 id="三维矩阵形式"><a href="#三维矩阵形式" class="headerlink" title="三维矩阵形式"></a>三维矩阵形式</h4><p>A是一个3✖️3矩阵，依然类似二元方程写成线性组合的形式如下</p><p><img src= "/img/loading.gif" data-lazy-src="/2020/08/18/MIT Linear Algebra 一/截屏2020-08-18 下午11.04.11.png" alt="截屏2020-08-18 下午10.43.48" style="zoom:50%;"></p><p>也就是说，左边是三个向量的线性组合，我们想要知道，怎样的组合才能得到右面这个向量，同样的画</p><p>出图像</p><p><img src= "/img/loading.gif" data-lazy-src="/2020/08/18/MIT Linear Algebra 一/截屏2020-08-18 下午11.06.28.png" alt="截屏2020-08-18 下午10.43.48" style="zoom:50%;"></p><p>根据我们的方程，我们要做的就是将这三个向量进行组合求得右侧向量，这时你已经看到了，在这个方程中，只要第三个向量就等于代求得b，在之后我们会讲到消元法，在实际工作中都是通过消元法来解得。</p><p>那么如果右面的向量【6，4，2】变了呢？变成其他的向量的话还依然有解吗？用线性组合的语言来说这个问题的话，也就是说，列的线性组合能不能覆盖整个三维空间呢?任意的b也就是三维空间中的所有b。</p><p>对于这个系数矩阵也就是</p><script type="math/tex; mode=display">\begin{bmatrix}1&2&&3\\2 &5&& 2\\6 &-3 &&1\\ \end{bmatrix}</script><p>答案是肯定的。这时A就叫非奇异矩阵，可逆矩阵。</p><h3 id="线性组合讨论"><a href="#线性组合讨论" class="headerlink" title="线性组合讨论"></a>线性组合讨论</h3><p>反过来想，什么时候这三个列向量不能进行线性组合呢？</p><p>举个例子，当三个列向量正好处于同一平面下时，这种情况下答案就是否定的，因为不管怎么组合，我们都得不到平面以外的向量，当b在平面内的时候，有解，在平面外就无解。</p><p>下面我们考虑九维的情况，假设九个方程九个未知数，这样系数矩阵就有9列，每一列都是九维空间的向量，然后可以考虑其线性组合。这样就得到了九维空间中九个向量的线性组合，我们通过线性组合得到b，同样的问题，是否总有解呢。</p><p>有时可以有时不可以，如果选择一些相互不独立的向量，也就是向量之间存在依赖，9列相当于8列，有一列是没有贡献的，那么线性组合就只能覆盖九维空间某八维平面。</p><h3 id="矩阵相乘"><a href="#矩阵相乘" class="headerlink" title="矩阵相乘"></a>矩阵相乘</h3><p>回到正题，目前我们只关注非奇异矩阵，接下来讲矩阵如何相乘</p><script type="math/tex; mode=display">\begin {bmatrix}2&5\\1&3\end{bmatrix}\begin{bmatrix}1\\2\end{bmatrix}</script><p>第一种方法：这个矩阵乘法是列的线性组合也就是</p><script type="math/tex; mode=display">\begin {bmatrix}2&5\\1&3\end{bmatrix}\begin{bmatrix}1\\2\end{bmatrix}=1\begin {bmatrix}2\\1\end{bmatrix}+2\begin{bmatrix}5\\3\end{bmatrix}=\begin{bmatrix}12\\7\end{bmatrix}</script><p>第二种方法：行乘以列的和，这里不做过多介绍，比较容易，我还是倾向于第一种做法</p><p>A成x看做是A各列的线性组合。</p>]]></content>
    
    
    <summary type="html">线性代数笔记</summary>
    
    
    
    <category term="数学" scheme="http://yoursite.com/categories/%E6%95%B0%E5%AD%A6/"/>
    
    
    <category term="线性代数" scheme="http://yoursite.com/tags/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"/>
    
  </entry>
  
</feed>
